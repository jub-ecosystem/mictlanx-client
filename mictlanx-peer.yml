x-peer-env: &peer_env
  # ---- runtime flags (match your script / clap args) ----
  # RUST_LOG: ${RUST_LOG:-mictlanx=debug,dev=debug}
  
  ENV: PROD
  RUST_BACKTRACE: 1
  BIN_NAME: ${BIN_NAME:-peer}
  USE_CARGO: ${USE_CARGO:-false}

  NODE_ID: ${NODE_ID:-mictlanx-peer-0}
  SERVER_IP_ADDR: ${SERVER_IP_ADDR:-0.0.0.0}
  IP_ADDRESS: ${IP_ADDRESS:-localhost}

  # Compose can't interpolate container-side env in port mapping,
  # so we use PEER_PORT for bind and pass PORT=PEER_PORT into the container.
  PORT: ${PEER_PORT:-24000}

  NODE_DISK_CAPACITY: ${NODE_DISK_CAPACITY:-10000000000}
  NODE_MEMORY_CAPACITY: ${NODE_MEMORY_CAPACITY:-1000000000}
  BASE_PATH: ${BASE_PATH:-/app/mictlanx}
  # Let the app derive local/data/log from BASE_PATH (leave empty to omit)
  # LOCAL_PATH: ${LOCAL_PATH:-/app/mictlanx/local}
  # DATA_PATH: ${DATA_PATH:-/app/mictlanx/data}
  # LOG_PATH: ${LOG_PATH:-/app/mictlanx/log}

  PEERS: ${PEERS:-}  # space-separated, e.g. "http://peer-2:25001 http://peer-3:25002"
  MIN_INTERVAL_TIME: ${MIN_INTERVAL_TIME:-5}
  MAX_INTERVAL_TIME: ${MAX_INTERVAL_TIME:-20}
  WORKERS: ${WORKERS:-2}

  PAYLOAD_LIMIT: ${PAYLOAD_LIMIT:-1000000000}
  CLIENT_REQUEST_TIMEOUT: ${CLIENT_REQUEST_TIMEOUT:-300}
  CLIENT_DISCONNECT_TIMEOUT: ${CLIENT_DISCONNECT_TIMEOUT:-30}

  # AGENT_UNIX_SOCKET_PATH: ${AGENT_UNIX_SOCKET_PATH:-/tmp/mictlanx.sock}
  CLEAN_CACHE: ${CLEAN_CACHE:-false}
  ELASTIC: ${ELASTIC:-true}
  PROTOCOL: ${PROTOCOL:-http}
  TRAVERSE_AND_CLEAN: ${TRAVERSE_AND_CLEAN:-true}
  DISK_CHECK_INTERVAL_TIME: ${DISK_CHECK_INTERVAL_TIME:-60}



services:
  mictlanx-peer-0:
    image: nachocode/mictlanx:peer-0.1.0a0
    container_name: ${NODE_ID:-mictlanx-peer-0}
    environment: *peer_env

    # Persist everything under /mictlanx (BASE_PATH lives there by default)
    volumes:
      # App writes metadata and objects under BASE_PATH; this keeps it on the host.
      - mictlanx-peer-0:${BASE_PATH:-/app/mictlanx}

    # Publish the peer API
    ports:
      - "${PEER_PORT:-24000}:${PEER_PORT:-24000}"

    # If your Dockerfile ENTRYPOINT already runs the binary, no command is needed.
    # Otherwise, run the binary and let the app read flags from env (as your code supports).
    # command: [ "peer" ]

    healthcheck:
      # prefer the built-in /health; fallback to stats if needed
      test: [ "CMD", "curl", "-fsS", "http://127.0.0.1:${PEER_PORT:-24000}/health" ]
      interval: 10s
      timeout: 3s
      retries: 10
      start_period: 10s

    restart: unless-stopped
    networks:
      - mictlanx

volumes:
  mictlanx-peer-0:

networks:
  mictlanx:
    external: true
